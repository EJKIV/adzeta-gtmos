/**
 * Autonomous Task Generator
 * 
 * Self-creates tasks based on:
 * - KPI anomalies (automatic investigation tasks)
 * - Blocked work (automatic unblock tasks)
 * - Strategic gaps (automatic strategy tasks)
 * 
 * Uses Phase 3 recommendation engine as trigger
 */

import type { 
  AutonomousTask, 
  AutonomousTaskType, 
  TaskPriority,
  TaskStatus,
} from './types';
import type { 
  Recommendation, 
  RecommendationPriority,
  RecommendationType 
} from '@/lib/intelligence/recommendation-engine';
import type { AnomalyResult } from '@/lib/predictions/types';

// Task creation thresholds
const THRESHOLDS = {
  autoAssignConfidence: 70, // Auto-assign if confidence > 70%
  autoExecutePriority: 'high' as RecommendationPriority, // Auto-create for high+ priority
  maxTasksPerTrigger: 3, // Don't create more than 3 tasks per trigger
  taskExpiryHours: 24, // Tasks expire after 24h if not completed
};

// Agent assignment rules
const AGENT_ASSIGNMENTS: Record<AutonomousTaskType, string[]> = {
  kpi_investigation: ['agent:analytics', 'agent:ops'],
  unblock_work: ['agent:ops', 'agent:dev'],
  strategic_gap: ['agent:strategy', 'agent:growth'],
  anomaly_response: ['agent:analytics', 'agent:ops'],
  proactive_mitigation: ['agent:ops', 'agent:dev'],
  ab_test_proposal: ['agent:growth', 'agent:design'],
};

// Task templates for each type
interface TaskTemplate {
  type: AutonomousTaskType;
  title: string;
  description: string;
  priority: TaskPriority;
}

// Generate unique ID
function generateId(): string {
  return `autotask_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Map recommendation priority to task priority
function mapPriority(recPriority: RecommendationPriority): TaskPriority {
  const mapping: Record<RecommendationPriority, TaskPriority> = {
    critical: 'critical',
    high: 'high',
    medium: 'medium',
    low: 'low',
  };
  return mapping[recPriority];
}

// Map recommendation type to task type
function mapRecTypeToTaskType(recType: RecommendationType): AutonomousTaskType | null {
  const mapping: Record<RecommendationType, AutonomousTaskType | null> = {
    investigate_decline: 'kpi_investigation',
    double_down_growth: 'strategic_gap',
    reorder_dashboard: null, // Don't create task for UI changes
    address_anomaly: 'anomaly_response',
    review_blocked_tasks: 'unblock_work',
    pause_underperforming: 'strategic_gap',
  };
  return mapping[recType];
}

/**
 * Autonomous Task Generator
 * 
 * Creates tasks automatically based on system signals and recommendations.
 */
export class AutonomousTaskGenerator {
  private tasks: Map<string, AutonomousTask> = new Map();
  private onTaskCreated?: (task: AutonomousTask) => void;
  
  constructor(options?: { onTaskCreated?: (task: AutonomousTask) => void }) {
    this.onTaskCreated = options?.onTaskCreated;
  }
  
  /**
   * Create tasks from recommendations generated by Phase 3 engine
   */
  createTasksFromRecommendations(recommendations: Recommendation[]): AutonomousTask[] {
    const newTasks: AutonomousTask[] = [];
    
    for (const rec of recommendations) {
      // Only create tasks for non-UI recommendations with sufficient priority
      if (rec.priority === 'low' || rec.suggestedAction.type === 'manual_review') {
        continue;
      }
      
      const taskType = mapRecTypeToTaskType(rec.type);
      if (!taskType) continue;
      
      // Check if task already exists for this recommendation
      const existing = this.findTaskByTrigger(rec.id);
      if (existing) continue;
      
      const task = this.buildTaskFromRecommendation(rec, taskType);
      this.tasks.set(task.id, task);
      newTasks.push(task);
      
      this.onTaskCreated?.(task);
    }
    
    return newTasks;
  }
  
  /**
   * Create tasks from KPI anomalies
   */
  createTasksFromAnomalies(anomalies: AnomalyResult[]): AutonomousTask[] {
    const newTasks: AutonomousTask[] = [];
    
    for (const anomaly of anomalies) {
      // Only create tasks for warning+ severity
      if (anomaly.severity === 'info') continue;
      
      const existing = this.findTaskByTrigger(anomaly.id);
      if (existing) continue;
      
      const task = this.buildTaskFromAnomaly(anomaly);
      this.tasks.set(task.id, task);
      newTasks.push(task);
      
      this.onTaskCreated?.(task);
    }
    
    return newTasks;
  }
  
  /**
   * Create task for blocked work
   */
  createUnblockTask(blockedCount: number, context?: {
    blockedTaskIds?: string[];
    blockerReasons?: string[];
  }): AutonomousTask | null {
    if (blockedCount < 2) return null;
    
    const existing = this.findPendingTaskByType('unblock_work');
    if (existing) return null; // Already have an unblock task pending
    
    const task: AutonomousTask = {
      id: generateId(),
      type: 'unblock_work',
      title: `Unblock ${blockedCount} blocked tasks`,
      description: `${blockedCount} tasks are currently blocked. ${
        context?.blockerReasons 
          ? `Common reasons: ${context.blockerReasons.slice(0, 3).join(', ')}`
          : 'Review and resolve blockers to restore workflow velocity.'
      }`,
      priority: blockedCount >= 5 ? 'high' : 'medium',
      status: 'pending',
      trigger: {
        type: 'blocked_work',
        sourceId: `blocked_work_${Date.now()}`,
        confidence: Math.min(90, 60 + blockedCount * 5),
      },
      autoAssigned: true,
      createdAt: new Date().toISOString(),
      dueAt: new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString(), // 12h
      context: {
        affectedMetrics: ['workflow_velocity', 'task_completion_rate'],
      },
      execution: {
        attempts: 0,
      },
    };
    
    this.autoAssign(task);
    this.tasks.set(task.id, task);
    this.onTaskCreated?.(task);
    
    return task;
  }
  
  /**
   * Create strategic tasks for identified gaps
   */
  createStrategicGapTasks(gaps: {
    type: string;
    description: string;
    impact: 'high' | 'medium' | 'low';
    affectedArea: string;
  }[]): AutonomousTask[] {
    const newTasks: AutonomousTask[] = [];
    
    for (let i = 0; i < Math.min(gaps.length, THRESHOLDS.maxTasksPerTrigger); i++) {
      const gap = gaps[i];
      
      const task: AutonomousTask = {
        id: generateId(),
        type: 'strategic_gap',
        title: `Address strategic gap: ${gap.affectedArea}`,
        description: gap.description,
        priority: gap.impact === 'high' ? 'high' : 'medium',
        status: 'pending',
        trigger: {
          type: 'strategic_gap',
          sourceId: `gap_${Date.now()}_${i}`,
          confidence: gap.impact === 'high' ? 85 : 70,
        },
        autoAssigned: true,
        createdAt: new Date().toISOString(),
        dueAt: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString(), // 48h
        context: {
          affectedMetrics: [gap.affectedArea.toLowerCase().replace(/\s+/g, '_')],
        },
        execution: {
          attempts: 0,
        },
      };
      
      this.autoAssign(task);
      this.tasks.set(task.id, task);
      newTasks.push(task);
      this.onTaskCreated?.(task);
    }
    
    return newTasks;
  }
  
  /**
   * Create proactive mitigation task
   */
  createProactiveMitigationTask(
    blockerId: string,
    description: string,
    confidence: number,
    preconditions: string[]
  ): AutonomousTask {
    const task: AutonomousTask = {
      id: generateId(),
      type: 'proactive_mitigation',
      title: 'Proactive blocker mitigation',
      description: `Prevent predicted blocker: ${description}`,
      priority: confidence >= 85 ? 'high' : 'medium',
      status: 'pending',
      trigger: {
        type: 'prediction',
        sourceId: blockerId,
        confidence,
      },
      autoAssigned: true,
      createdAt: new Date().toISOString(),
      dueAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24h
      context: {
        historicalPatterns: [],
      },
      execution: {
        attempts: 0,
      },
    };
    
    this.autoAssign(task);
    this.tasks.set(task.id, task);
    this.onTaskCreated?.(task);
    
    return task;
  }
  
  /**
   * Get all tasks
   */
  getAllTasks(): AutonomousTask[] {
    return Array.from(this.tasks.values());
  }
  
  /**
   * Get pending tasks
   */
  getPendingTasks(): AutonomousTask[] {
    return this.getAllTasks().filter(t => t.status === 'pending');
  }
  
  /**
   * Get tasks by type
   */
  getTasksByType(type: AutonomousTaskType): AutonomousTask[] {
    return this.getAllTasks().filter(t => t.type === type);
  }
  
  /**
   * Get task by ID
   */
  getTask(id: string): AutonomousTask | undefined {
    return this.tasks.get(id);
  }
  
  /**
   * Update task status
   */
  updateTaskStatus(id: string, status: TaskStatus): boolean {
    const task = this.tasks.get(id);
    if (!task) return false;
    
    task.status = status;
    
    if (status === 'in_progress' && !task.assignedAt) {
      task.assignedAt = new Date().toISOString();
    }
    
    if (status === 'completed') {
      task.completedAt = new Date().toISOString();
    }
    
    return true;
  }
  
  /**
   * Record task execution attempt
   */
  recordAttempt(id: string, error?: string): boolean {
    const task = this.tasks.get(id);
    if (!task) return false;
    
    if (!task.execution) {
      task.execution = { attempts: 0 };
    }
    
    task.execution.attempts++;
    task.execution.lastAttemptAt = new Date().toISOString();
    
    if (error) {
      task.execution.error = error;
    }
    
    return true;
  }
  
  /**
   * Clean up expired tasks
   */
  cleanupExpiredTasks(): number {
    const now = Date.now();
    const expiryMs = THRESHOLDS.taskExpiryHours * 60 * 60 * 1000;
    let removed = 0;
    
    for (const [id, task] of this.tasks) {
      const created = new Date(task.createdAt).getTime();
      if (now - created > expiryMs && task.status !== 'completed') {
        task.status = 'cancelled';
        removed++;
      }
    }
    
    return removed;
  }
  
  /**
   * Get task statistics
   */
  getStats(): {
    total: number;
    byStatus: Record<TaskStatus, number>;
    byType: Record<AutonomousTaskType, number>;
    createdToday: number;
    completedToday: number;
  } {
    const tasks = this.getAllTasks();
    const today = new Date().toISOString().split('T')[0];
    
    const byStatus: Record<TaskStatus, number> = {
      pending: 0,
      assigned: 0,
      in_progress: 0,
      completed: 0,
      cancelled: 0,
    };
    
    const byType: Record<AutonomousTaskType, number> = {
      kpi_investigation: 0,
      unblock_work: 0,
      strategic_gap: 0,
      anomaly_response: 0,
      proactive_mitigation: 0,
      ab_test_proposal: 0,
    };
    
    let createdToday = 0;
    let completedToday = 0;
    
    for (const task of tasks) {
      byStatus[task.status]++;
      byType[task.type]++;
      
      if (task.createdAt.startsWith(today)) createdToday++;
      if (task.completedAt?.startsWith(today)) completedToday++;
    }
    
    return {
      total: tasks.length,
      byStatus,
      byType,
      createdToday,
      completedToday,
    };
  }
  
  // Private helper methods
  
  private buildTaskFromRecommendation(
    rec: Recommendation,
    taskType: AutonomousTaskType
  ): AutonomousTask {
    const task: AutonomousTask = {
      id: generateId(),
      type: taskType,
      title: rec.title,
      description: rec.description,
      priority: mapPriority(rec.priority),
      status: 'pending',
      trigger: {
        type: 'recommendation',
        sourceId: rec.id,
        confidence: rec.confidenceScore,
      },
      autoAssigned: rec.confidenceScore >= THRESHOLDS.autoAssignConfidence,
      createdAt: new Date().toISOString(),
      dueAt: rec.expiresAt,
      context: {
        affectedMetrics: rec.sourceMetrics,
        relatedRecommendations: [rec.id],
      },
      execution: {
        attempts: 0,
      },
    };
    
    if (task.autoAssigned) {
      this.autoAssign(task);
    }
    
    return task;
  }
  
  private buildTaskFromAnomaly(anomaly: AnomalyResult): AutonomousTask {
    const priority: TaskPriority = anomaly.severity === 'critical' ? 'critical' : 'high';
    
    const task: AutonomousTask = {
      id: generateId(),
      type: 'anomaly_response',
      title: `Investigate ${anomaly.metric} ${anomaly.type}`,
      description: anomaly.message,
      priority,
      status: 'pending',
      trigger: {
        type: 'kpi_anomaly',
        sourceId: anomaly.id,
        confidence: anomaly.severity === 'critical' ? 95 : 80,
      },
      autoAssigned: true,
      createdAt: new Date().toISOString(),
      dueAt: new Date(Date.now() + 6 * 60 * 60 * 1000).toISOString(), // 6h for anomalies
      context: {
        affectedMetrics: [anomaly.metric],
      },
      execution: {
        attempts: 0,
      },
    };
    
    this.autoAssign(task);
    return task;
  }
  
  private autoAssign(task: AutonomousTask): void {
    const agents = AGENT_ASSIGNMENTS[task.type];
    if (agents && agents.length > 0) {
      // Simple round-robin assignment (in production would consider load)
      task.assignedTo = agents[0];
    }
  }
  
  private findTaskByTrigger(sourceId: string): AutonomousTask | undefined {
    return this.getAllTasks().find(t => t.trigger.sourceId === sourceId);
  }
  
  private findPendingTaskByType(type: AutonomousTaskType): AutonomousTask | undefined {
    return this.getAllTasks().find(
      t => t.type === type && !['completed', 'cancelled'].includes(t.status)
    );
  }
}

// Singleton instance
let globalTaskGenerator: AutonomousTaskGenerator | null = null;

/**
 * Get or create global task generator instance
 */
export function getTaskGenerator(
  options?: { onTaskCreated?: (task: AutonomousTask) => void }
): AutonomousTaskGenerator {
  if (!globalTaskGenerator) {
    globalTaskGenerator = new AutonomousTaskGenerator(options);
  }
  return globalTaskGenerator;
}

/**
 * Reset global instance (useful for testing)
 */
export function resetTaskGenerator(): void {
  globalTaskGenerator = null;
}
