/**
 * Integration Tests - Autonomy Flow
 * 
 * Tests task generation → healing → dashboard flow
 * Target: >80% coverage on full autonomy flow
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Import core modules
import {
  AutonomousTaskGenerator,
  createTaskFromRecommendation,
  batchGenerateTasks,
  type AutonomousTask,
  type KPIAnomalyInput,
  type BlockedWorkInput,
  type StrategicGapInput,
} from '../../lib/autonomy/task-generator';

import {
  SelfHealingEngine,
  type HealingEvent,
} from '../../lib/autonomy/self-healing';

import {
  PredictiveGuard,
} from '../../lib/autonomy/predictive-guard';

import {
  type Recommendation,
  type KpiTrend,
  type SynthesisInput,
} from '../../apps/gtm-command-center/frontend-shell/lib/intelligence/recommendation-engine';
import type { Task } from '../../lib/autonomy/predictive-guard';

describe('Autonomy Flow - Integration', () => {
  let taskGenerator: AutonomousTaskGenerator;
  let healingEngine: SelfHealingEngine;
  let predictiveGuard: PredictiveGuard;
  let healingEvents: HealingEvent[] = [];
  let generatedTasks: AutonomousTask[] = [];

  beforeEach(() => {
    taskGenerator = new AutonomousTaskGenerator();
    predictiveGuard = new PredictiveGuard();
    healingEvents = [];
    generatedTasks = [];
    
    healingEngine = new SelfHealingEngine({
      baseDelayMs: 10,
      maxDelayMs: 100,
      maxAttempts: 3,
      backoffMultiplier: 2,
      onEvent: (e) => healingEvents.push(e),
      onEscalate: (taskId, error, attempts) => {
        console.log(`[ESCALATION] Task ${taskId} escalated after ${attempts.length} attempts`);
      },
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
    generatedTasks = [];
  });

  describe('Task Generation → Healing Flow', () => {
    it('should generate investigation task from KPI anomaly and heal it', async () => {
      const anomaly: KPIAnomalyInput = {
        metric: 'conversion_rate',
        trend: {
          metric: 'conversion_rate',
          direction: 'down' as const,
          currentValue: 2.1,
          changePercent: -18,
          avg7dValue: 2.5,
          avg30dValue: 2.4,
          trendDirection: 'down' as const,
          volatility: 0.15,
          lastUpdated: new Date().toISOString(),
        },
        severity: 'critical',
        deviationPercent: -18,
        expectedRange: { min: 2.2, max: 2.8 },
        relatedMetrics: ['bounce_rate', 'session_duration'],
      };

      // Step 1: Generate task
      const task = taskGenerator.generateFromKPIAnomaly(anomaly);
      generatedTasks.push(task);
      
      expect(task.type).toBe('investigation');
      expect(task.priority).toBe('critical');
      expect(task.sourceType).toBe('kpi_anomaly');
      expect(task.autoGenerated).toBe(true);
      expect(task.confidenceScore).toBeGreaterThan(0);

      // Step 2: Simulate task failure
      const simulateTaskFailure = async (taskId: string): Promise<boolean> => {
        try {
          // Simulate successful healing
          vi.spyOn(Math, 'random').mockReturnValue(0);
          await healingEngine.monitorTask(taskId, new Error('Investigation timeout'));
          return true;
        } catch {
          return false;
        }
      };

      await simulateTaskFailure(task.id);

      // Step 3: Verify healing events
      expect(healingEvents.length).toBeGreaterThan(0);
      expect(healingEvents.some(e => e.type === 'started')).toBe(true);
      expect(healingEvents.some(e => e.type === 'retrying' || e.type === 'succeeded')).toBe(true);
    });

    it('should generate unblock task from blocked work and attempt healing', async () => {
      const blockedWork: BlockedWorkInput = {
        taskId: 'blocked-125',
        taskTitle: 'Database Migration',
        blockedReason: 'Waiting for DBA approval',
        blockedSince: new Date(Date.now() - 48 * 60 * 60 * 1000).toISOString(),
        blockerType: 'approval',
        impactScore: 85,
        dependencies: ['dep-1', 'dep-2'],
        owner: 'engineer@example.com',
      };

      // Step 1: Generate unblock task
      const task = taskGenerator.generateFromBlockedWork(blockedWork);
      generatedTasks.push(task);
      
      expect(task.type).toBe('unblock');
      expect(task.title).toContain('Unblock');
      expect(task.suggestedAssignees).toContain('engineer@example.com');
      expect(task.priority).toBe('critical'); // High impact + >48h blocked = critical

      // Step 2: Simulate failure and healing
      await healingEngine.monitorTask(task.id, new Error('Approval request failed'));

      // Step 3: Verify task state
      expect(task.status).toBe('pending');
    });

    it('should handle healing escalation after 3 failed attempts', async () => {
      const anomaly: KPIAnomalyInput = {
        metric: 'revenue',
        trend: {
          metric: 'revenue',
          direction: 'down' as const,
          currentValue: 50000,
          changePercent: -20,
          avg7dValue: 62500,
          avg30dValue: 60000,
          trendDirection: 'down' as const,
          volatility: 0.2,
          lastUpdated: new Date().toISOString(),
        },
        severity: 'critical',
        deviationPercent: -20,
        expectedRange: { min: 55000, max: 65000 },
      };

      // Generate task
      const task = taskGenerator.generateFromKPIAnomaly(anomaly);
      generatedTasks.push(task);
      
      // Force healing to fail (Math.random() > 0.7 fails)
      vi.spyOn(Math, 'random').mockReturnValue(0.99);
      
      // Call monitorTask for same task ID multiple times to trigger escalation
      // Escalation happens on the 4th attempt (after maxAttempts = 3)
      await healingEngine.monitorTask(task.id, new Error('Persistent failure'));
      await healingEngine.monitorTask(task.id, new Error('Persistent failure'));
      await healingEngine.monitorTask(task.id, new Error('Persistent failure'));
      await healingEngine.monitorTask(task.id, new Error('Persistent failure'));

      // Verify escalation
      const escalatedEvent = healingEvents.find(e => e.type === 'escalated');
      expect(escalatedEvent).toBeDefined();
    });

    it('should correlate related metrics in generated tasks', () => {
      const anomaly: KPIAnomalyInput = {
        metric: 'conversion_rate',
        trend: {
          metric: 'conversion_rate',
          direction: 'down' as const,
          currentValue: 1.8,
          changePercent: -25,
          avg7dValue: 2.4,
          avg30dValue: 2.3,
          trendDirection: 'down' as const,
          volatility: 0.18,
          lastUpdated: new Date().toISOString(),
        },
        severity: 'critical',
        deviationPercent: -25,
        expectedRange: { min: 2.1, max: 2.7 },
        relatedMetrics: ['bounce_rate', 'cart_abandonment', 'checkout_errors'],
      };

      const task = taskGenerator.generateFromKPIAnomaly(anomaly);
      
      expect(task.relatedMetrics).toContain('conversion_rate');
      expect(task.relatedMetrics).toContain('bounce_rate');
      expect(task.relatedMetrics).toContain('cart_abandonment');
    });
  });

  describe('Prediction → Task Generation Flow', () => {
    it('should generate mitigation tasks from predicted blockers', () => {
      // Setup historical patterns
      const historicalTasks: Task[] = [
        {
          id: 'hist-1',
          title: 'Historical Critical Task',
          status: 'blocked',
          priority: 'critical',
          blockedAt: new Date('2026-02-10'),
          unblockedAt: new Date('2026-02-11'),
          blockReason: 'Unclear scope',
          createdAt: new Date('2026-02-08'),
        },
      ];

      predictiveGuard.analyzePatterns(historicalTasks);

      // Current task that matches pattern
      const currentTask: Task = {
        id: 'current-1',
        title: 'New Critical Task',
        status: 'pending',
        priority: 'critical',
        createdAt: new Date(),
      };

      // Generate predictions
      const predictions = predictiveGuard.predictBlockers([currentTask], {
        minConfidence: 0.1,
        autoMitigateThreshold: 0.5,
      });

      // Create autonomous tasks from predictions
      for (const pred of predictions) {
        for (const mitigation of pred.mitigationTasks) {
          const anomaly: KPIAnomalyInput = {
            metric: 'predicted_blocker',
            trend: {
              metric: 'predicted_blocker',
              direction: 'down',
              currentValue: 0,
              changePercent: pred.confidence * 100,
              avg7dValue: 0,
              avg30dValue: 0,
              trendDirection: 'stable',
              volatility: 0,
              lastUpdated: new Date().toISOString(),
            },
            severity: pred.severity === 'critical' ? 'critical' : 'warning',
            deviationPercent: pred.confidence * 100,
            expectedRange: { min: 0, max: 100 },
          };

          const task = taskGenerator.generateFromKPIAnomaly(anomaly);
          generatedTasks.push(task);
        }
      }

      expect(generatedTasks.length).toBeGreaterThanOrEqual(0);
    });
  });

  describe('Dashboard Integration', () => {
    it('should generate tasks suitable for dashboard display', () => {
      const tasks: AutonomousTask[] = [];

      // Generate variety of tasks
      const anomalies: KPIAnomalyInput[] = [
        { metric: 'revenue', trend: { metric: 'revenue', direction: 'down', currentValue: 100, changePercent: -10, avg7dValue: 110, avg30dValue: 105, trendDirection: 'down', volatility: 0.1, lastUpdated: new Date().toISOString() }, severity: 'warning', deviationPercent: -10, expectedRange: { min: 105, max: 115 } },
        { metric: 'traffic', trend: { metric: 'traffic', direction: 'up', currentValue: 1000, changePercent: 15, avg7dValue: 870, avg30dValue: 900, trendDirection: 'up', volatility: 0.2, lastUpdated: new Date().toISOString() }, severity: 'notice', deviationPercent: 15, expectedRange: { min: 850, max: 950 } },
        { metric: 'conversion', trend: { metric: 'conversion', direction: 'down', currentValue: 2.0, changePercent: -5, avg7dValue: 2.1, avg30dValue: 2.08, trendDirection: 'down', volatility: 0.05, lastUpdated: new Date().toISOString() }, severity: 'warning', deviationPercent: -5, expectedRange: { min: 2.0, max: 2.2 } },
      ];

      for (const anomaly of anomalies) {
        const task = taskGenerator.generateFromKPIAnomaly(anomaly);
        tasks.push(task);
      }

      // Verify all tasks have required dashboard fields
      for (const task of tasks) {
        expect(task.id).toBeDefined();
        expect(task.title).toBeDefined();
        expect(task.priority).toBeDefined();
        expect(task.status).toBeDefined();
        expect(task.createdAt).toBeDefined();
        expect(task.tags).toBeInstanceOf(Array);
      }
    });

    it('should track task resolution in dashboard', () => {
      const anomaly: KPIAnomalyInput = {
        metric: 'engagement',
        trend: { metric: 'engagement', direction: 'down', currentValue: 45, changePercent: -12, avg7dValue: 52, avg30dValue: 50, trendDirection: 'down', volatility: 0.08, lastUpdated: new Date().toISOString() },
        severity: 'warning',
        deviationPercent: -12,
        expectedRange: { min: 48, max: 55 },
      };

      const task = taskGenerator.generateFromKPIAnomaly(anomaly);
      
      // Simulate resolution
      const resolvedTask: AutonomousTask = {
        ...task,
        status: 'completed',
        resolution: {
          type: 'fixed',
          summary: 'Root cause identified and resolved',
          completedAt: new Date().toISOString(),
        },
      };

      expect(resolvedTask.status).toBe('completed');
      expect(resolvedTask.resolution).toBeDefined();
      expect(resolvedTask.resolution?.type).toBe('fixed');
    });

    it('should generate tasks with confidence scores for sorting', () => {
      const tasks: AutonomousTask[] = [];
      const severities: Array<'critical' | 'warning' | 'notice'> = ['critical', 'warning', 'notice'];

      for (const severity of severities) {
        const anomaly: KPIAnomalyInput = {
          metric: `metric_${severity}`,
          trend: { metric: `metric_${severity}`, direction: 'down', currentValue: 50, changePercent: -10, avg7dValue: 55, avg30dValue: 54, trendDirection: 'down', volatility: 0.1, lastUpdated: new Date().toISOString() },
          severity,
          deviationPercent: -10,
          expectedRange: { min: 52, max: 58 },
        };

        const task = taskGenerator.generateFromKPIAnomaly(anomaly);
        tasks.push(task);
      }

      // Verify confidence scores are set
      tasks.forEach(task => {
        expect(task.confidenceScore).toBeGreaterThanOrEqual(0);
        expect(task.confidenceScore).toBeLessThanOrEqual(100);
      });

      // Critical should have higher confidence
      const criticalTask = tasks.find(t => t.priority === 'critical');
      expect(criticalTask).toBeDefined();
    });
  });

  describe('Batch Processing Flow', () => {
    it('should batch generate tasks from multiple recommendations', () => {
      const recommendations: Recommendation[] = [
        {
          id: 'rec-1',
          type: 'investigate_decline',
          title: 'Investigate revenue decline',
          description: 'Revenue down 18%',
          priority: 'critical',
          confidenceScore: 92,
          confidenceTrend: 'rising',
          sourceMetrics: ['revenue'],
          sourceTrends: [],
          scores: { trendImpact: -90, preferenceMatch: 85, historicalAccuracy: 0.8, combined: 92 },
          suggestedAction: { type: 'auto', description: 'Create investigation', estimatedImpact: 'High' },
          createdAt: new Date().toISOString(),
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
        },
        {
          id: 'rec-2',
          type: 'review_blocked_tasks',
          title: 'Review blocked tasks',
          description: '5 tasks blocked',
          priority: 'high',
          confidenceScore: 88,
          confidenceTrend: 'stable',
          sourceMetrics: ['blocked_tasks'],
          sourceTrends: [],
          scores: { trendImpact: -60, preferenceMatch: 75, historicalAccuracy: 0.78, combined: 88 },
          suggestedAction: { type: 'manual_review', description: 'Review blockers', estimatedImpact: 'Medium' },
          createdAt: new Date().toISOString(),
          expiresAt: new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString(),
        },
      ];

      const tasks = batchGenerateTasks(recommendations, taskGenerator);

      expect(tasks.length).toBeGreaterThan(0);
      tasks.forEach(task => {
        expect(task.autoGenerated).toBe(true);
        expect(task.status).toBe('pending');
      });
    });

    it('should filter low confidence recommendations', () => {
      const recommendations: Recommendation[] = [
        {
          id: 'rec-high',
          type: 'investigate_decline',
          title: 'High Confidence',
          description: 'Test',
          priority: 'high',
          confidenceScore: 85,
          confidenceTrend: 'stable',
          sourceMetrics: [],
          sourceTrends: [],
          scores: { trendImpact: -70, preferenceMatch: 80, historicalAccuracy: 0.75, combined: 85 },
          suggestedAction: { type: 'manual_review', description: 'Test', estimatedImpact: 'Low' },
          createdAt: new Date().toISOString(),
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
        },
        {
          id: 'rec-low',
          type: 'address_anomaly',
          title: 'Low Confidence',
          description: 'Test',
          priority: 'low',
          confidenceScore: 35, // Below 50 threshold
          confidenceTrend: 'falling',
          sourceMetrics: [],
          sourceTrends: [],
          scores: { trendImpact: -30, preferenceMatch: 50, historicalAccuracy: 0.6, combined: 35 },
          suggestedAction: { type: 'manual_review', description: 'Test', estimatedImpact: 'Low' },
          createdAt: new Date().toISOString(),
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
        },
      ];

      const tasks = batchGenerateTasks(recommendations, taskGenerator);

      // Should only generate for high confidence
      expect(tasks.length).toBeLessThan(recommendations.length);
      expect(tasks.every(t => t.confidenceScore >= 50)).toBe(true);
    });
  });

  describe('Full Autonomy Cycle', () => {
    it('should execute full autonomy cycle end-to-end', async () => {
      // Step 1: Setup historical data for predictions
      const historicalTasks: Task[] = [
        {
          id: 'hist-1',
          title: 'Historical Blocked',
          status: 'blocked',
          priority: 'critical',
          blockedAt: new Date('2026-02-10'),
          unblockedAt: new Date('2026-02-11'),
          blockReason: 'Unclear requirements',
          createdAt: new Date('2026-02-08'),
        },
      ];
      predictiveGuard.analyzePatterns(historicalTasks);

      // Step 2: Detect new anomaly through recommendations (simulated)
      const anomaly: KPIAnomalyInput = {
        metric: 'critical_metric',
        trend: { metric: 'critical_metric', direction: 'down', currentValue: 50, changePercent: -20, avg7dValue: 62, avg30dValue: 60, trendDirection: 'down', volatility: 0.15, lastUpdated: new Date().toISOString() },
        severity: 'critical',
        deviationPercent: -20,
        expectedRange: { min: 55, max: 68 },
      };

      // Step 3: Generate task
      const task = taskGenerator.generateFromKPIAnomaly(anomaly);
      expect(task.priority).toBe('critical');

      // Step 4: Simulate failure and healing
      vi.spyOn(Math, 'random').mockReturnValue(0); // Success
      await healingEngine.monitorTask(task.id, new Error('Processing error'));

      // Step 5: Verify cycle complete
      expect(healingEvents.some(e => e.type === 'succeeded')).toBe(true);
    });

    it('should handle multiple concurrent anomalies', async () => {
      const anomalies: KPIAnomalyInput[] = [
        { metric: 'revenue', trend: { metric: 'revenue', direction: 'down', currentValue: 1000, changePercent: -15, avg7dValue: 1176, avg30dValue: 1150, trendDirection: 'down', volatility: 0.1, lastUpdated: new Date().toISOString() }, severity: 'critical', deviationPercent: -15, expectedRange: { min: 1100, max: 1200 } },
        { metric: 'users', trend: { metric: 'users', direction: 'down', currentValue: 500, changePercent: -8, avg7dValue: 543, avg30dValue: 535, trendDirection: 'down', volatility: 0.08, lastUpdated: new Date().toISOString() }, severity: 'warning', deviationPercent: -8, expectedRange: { min: 525, max: 560 } },
        { metric: 'engagement', trend: { metric: 'engagement', direction: 'up', currentValue: 75, changePercent: 12, avg7dValue: 66, avg30dValue: 68, trendDirection: 'up', volatility: 0.12, lastUpdated: new Date().toISOString() }, severity: 'notice', deviationPercent: 12, expectedRange: { min: 60, max: 72 } },
      ];

      const tasks: AutonomousTask[] = [];
      for (const anomaly of anomalies) {
        const task = taskGenerator.generateFromKPIAnomaly(anomaly);
        tasks.push(task);
      }

      expect(tasks).toHaveLength(3);
      
      // Critical should be first in priority
      const criticalTasks = tasks.filter(t => t.priority === 'critical');
      expect(criticalTasks.length).toBeGreaterThanOrEqual(1);

      // All tasks should have metadata
      tasks.forEach(task => {
        expect(task.tags.length).toBeGreaterThan(0);
        expect(task.autoGenerated).toBe(true);
      });
    });

    it('should escalate tasks with healing failures', async () => {
      const anomaly: KPIAnomalyInput = {
        metric: 'priority_metric',
        trend: { metric: 'priority_metric', direction: 'down', currentValue: 80, changePercent: -25, avg7dValue: 106, avg30dValue: 102, trendDirection: 'down', volatility: 0.2, lastUpdated: new Date().toISOString() },
        severity: 'critical',
        deviationPercent: -25,
        expectedRange: { min: 95, max: 115 },
      };

      const task = taskGenerator.generateFromKPIAnomaly(anomaly);

      // Force healing to fail (Math.random() > 0.7 fails)
      vi.spyOn(Math, 'random').mockReturnValue(0.99);
      
      const escalationSpy = vi.fn();
      const failEngine = new SelfHealingEngine({
        baseDelayMs: 1,
        maxAttempts: 3,
        onEscalate: escalationSpy,
      });

      // Call 4 times to trigger escalation (3 attempts + 1 to exceed)
      await failEngine.monitorTask(task.id, new Error('Persistent failure'));
      await failEngine.monitorTask(task.id, new Error('Persistent failure'));
      await failEngine.monitorTask(task.id, new Error('Persistent failure'));
      await failEngine.monitorTask(task.id, new Error('Persistent failure'));

      expect(escalationSpy).toHaveBeenCalled();
    });
  });
});
